#!/usr/bin/env bash
# Author: Darren Klein
# Github repo: https://github.com/darrenklein/trash

# A safe alternative to rm/rmdir, trash can be called with any number of arguments, for example:
# $ trash index.html scr scripts README.md
# It will rename duplicate file/directories using the macOS convention of inserting/appending the time the duplicate resource was deleted.
# For example, sequentially trashing two "index.html" files via `$ trash index.html`:
#
# index.html
# index 3:45 PM.html
#
# Trashing multiple items at once produces a behavior that is unique to this script, but I believe that it is a reasonable expectation;
# Duplicate files in the same batch will initially have the time inserted/appended, but on finding additional duplicates in the batch of processed items,
# a unique numeric identified will be added as well. For example, trashing multiple index.html files from different sources via `$ trash index.html test_1/index.html test_2/index.html test_3/index.html`:
#
# index.html
# index 3:45 PM.html
# index 3:45 PM.html (1)
# index 3:45 PM.html (2)

#########################################################
# Lowercase the names of trashed items and trash content
# Used to compare item names and detect duplicates
#########################################################
make_lowercase() {
    echo "$1" | tr "[:upper:]" "[:lower:]"
}

#########################################################
# Check to see if an array contains a value
#########################################################
contains() {
    arr=("$@")
    ((last_idx=${#arr[@]} - 1))
    item=${arr[last_idx]}
    unset arr[last_idx]

    [[ "${arr[@]}" =~ (^| )"'$item'"($| ) ]] && return 0 || return 1
}

#######################################################################################
# Check to see if the target is a directory or a file with no extension
#######################################################################################
has_no_extension() {
    [[ -d "$1" || "$1" != *"."* ]] && return 0 || return 1   
}

#########################################################
# Move the target files/directories into the trash
#########################################################
handle_move() {
    lowercase_name=$( make_lowercase "$2" )
    lowercase_trashed_items=$( make_lowercase "${trashed_items[*]}" )
    # Count any duplicates in the batch of items that have been trashed during this operation;
    # for example, $ trash x a/x y/x z/x
    # This number will be appended to the modified file name as a unique identifier.
    dup_count=$( grep -o "$lowercase_name" <<< "$lowercase_trashed_items" | wc -l | tr -d " " )

    if [ "$dup_count" -gt 0 ]
    then
        mv -fv "$1" ~/.Trash/"$2 ($dup_count)"
    else
        mv -fv "$1" ~/.Trash/"$2"
    fi

    # Push the trashed item into the array of trashed_items,
    # used when checking for the existence of an identically-named item.
    lci=$( make_lowercase "$2" )
    trashed_items+=("'$lci'")
}

usage="usage: trash source1 source2 ... sourceN"
time=$(date "+%-I.%M.%S %p") # Format the time like 9.32.16 PM - the "-" trims the leading 0.
trash_content=$( ls ~/.Trash ) # Put the contents of the trash into an array.
trashed_items=() # An empty array to hold items trashed during this execution.
lowercase_trash_content=()

# Loop through the trash, lowercasing every item and wrapping it in single-quotes.
for item in ~/.Trash/*; do
    basename=$( basename "$item" )
    lowercase_item=$( make_lowercase "$basename" )
    lowercase_trash_content+=("'$lowercase_item'")
done


#########################################################
# Usage - invoked when no arguments passed
#########################################################
if [ "$#" == "0" ]
then
    echo "$usage"
    exit 1
fi

#########################################################
# Execution
#########################################################
while (( "$#" )); do
    source=$( ( [ -d "$1" ] && [ "${1: -1}" == / ] ) && echo "${1%?}" || echo "${1}" ) # if the item is a directory and ends with a forward slash, strip the slash so it'll correctly match an existing item in the trash.
    basename=$( basename "$source" )
    lowercase_basename=$( make_lowercase "$basename" ) # for comparing file/dir names, use the basename.

    # First, check the array of items that have been successfully trashed in this transaction.
    # If there's a match, no need to check the trash content, as we can infer that there's already an item with that name in there.
    if contains "${trashed_items[@]}" "$lowercase_basename"
    then
        if has_no_extension "$source";
        then
            handle_move "$source" "${basename} ${time}"
        else
            name="${basename%.*}"
            extension="${basename##*.}"
            handle_move "$source" "${name} ${time}.${extension}"
        fi
    else
        if contains "${lowercase_trash_content[@]}" "$lowercase_basename"
        then
            if has_no_extension "$source";
            then
                handle_move "$source" "${basename} ${time}"
            else
                name="${basename%.*}"
                extension="${basename##*.}"
                handle_move "$source" "${name} ${time}.${extension}"
            fi
        else
            handle_move "$source" "$basename"
        fi
    fi

    shift
done
