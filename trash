#!/usr/bin/env bash
# Author: Darren Klein
# Github repo: https://github.com/darrenklein/trash

# A safe alternative to rm/rmdir, trash can be called with any number of arguments, for example:
# $ trash index.html scr scripts README.md
# It will rename duplicate file/directories using the macOS convention of inserting/appending the time the duplicate resource was deleted.
# For example, sequentially trashing two "index.html" files via `$ trash index.html`:
#
# index.html
# index 3:45 PM.html
#
# Trashing multiple items at once produces a behavior that is unique to this script, but I believe that it is a reasonable expectation;
# Duplicate files in the same batch will initially have the time inserted/appended, but on finding additional duplicates in the batch of processed items,
# a unique numeric identified will be added as well. For example, trashing multiple index.html files from different sources via `$ trash index.html test_1/index.html test_2/index.html test_3/index.html`:
#
# index.html
# index 3:45 PM.html
# index 3:45 PM.html (1)
# index 3:45 PM.html (2)

usage="usage: trash source1 source2 ... sourceN"
time=$(date "+%-I.%M.%S %p") # format the time like 9.32.16 PM - the "-" trims the leading 0.
trash_content=$( ls ~/.Trash ) # put the contents of the trash into an array.
trashed_items=() # An empty array to hold items trashed during this execution.

#########################################################
# Move the target files/directories into the trash
# $1 - source path, required
# $2 - target path, required
#########################################################
handle_move() {
    lowercase_name=$( echo "$2" | tr "[:upper:]" "[:lower:]" )
    lowercase_trashed_items=$( echo ${trashed_items[*]} | tr "[:upper:]" "[:lower:]" )
    # Count any duplicates in the batch of items that have been trashed during this operation;
    # for example, $ trash x a/x y/x z/x
    # This number will be appended to the modified file name as a unique identifier.
    dup_count=$( grep -o "$lowercase_name" <<< "$lowercase_trashed_items" | wc -l | tr -d "[:space:]" )

    if [ "$dup_count" -gt 0 ]
    then
        mv -fv "$1" ~/.Trash/"$2 ($dup_count)"
    else
        mv -fv "$1" ~/.Trash/"$2"
    fi

    # Push the trashed item into the array of trashed_items,
    # used when checking for the existence of an identically-named item.
    trashed_items+=("$2")
}

#########################################################
# Usage
# Invoked when no arguments passed.
#########################################################
if [ "$#" == "0" ]
then
    echo "$usage"
    exit 1
fi

#########################################################
# Execution
#########################################################
while (( "$#" )); do
    source=$( ( [ -d "$1" ] && [ "${1: -1}" == / ] ) && echo "${1%?}" || echo "${1}" ) # if the item is a directory and ends with a forward slash, strip the slash so it'll correctly match an existing item in the trash.
    basename=$( basename "$source" )
    lowercase_basename=$( echo "$basename" | tr "[:upper:]" "[:lower:]" ) # for comparing file/dir names, use the basename.

    if [ $( echo "$trashed_items" | sed "s:.*/::" | tr "[:upper:]" "[:lower:]" | grep "^$lowercase_basename\$" ) ]
    then
        if [[ -d "$source" || "$source" != *"."* ]]
        then
            handle_move "$source" "${basename} ${time}"
        else
            name="${basename%.*}"
            extension="${basename##*.}"
            handle_move "$source" "${name} ${time}.${extension}"
        fi
    else
        if [ $(echo "$trash_content" | sed "s:.*/::" | tr "[:upper:]" "[:lower:]" | grep "^$lowercase_basename\$") ]
        then
            # Use the same naming strategy for directories and files with no extension.
            if [[ -d "$source" || "$source" != *"."* ]]
            then
                handle_move "$source" "${basename} ${time}"
            else
                name="${basename%.*}"
                extension="${basename##*.}"
                handle_move "$source" "${name} ${time}.${extension}"
            fi
        else
            handle_move "$source" "$basename"
        fi
    fi

    shift
done
