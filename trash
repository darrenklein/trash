#!/usr/bin/env bash
# Author: Darren Klein
# Github repo: https://github.com/darrenklein/trash

# A safe alternative to rm/rmdir, trash can be called with any number of arguments, for example:
# $ trash index.html scr scripts README.md
# It will rename duplicate file/directories using the macOS convention of inserting/appending the time the duplicate resource was deleted.
# For example, sequentially trashing two "index.html" files via `$ trash index.html`:
#
# index.html
# index 3:45 PM.html
#
# Trashing multiple items at once produces a behavior that is unique to this script, but I believe that it is a reasonable expectation;
# Duplicate files in the same batch will initially have the time inserted/appended, but on finding additional duplicates in the batch of processed items,
# a unique numeric identified will be added as well. For example, trashing multiple index.html files from different sources via `$ trash index.html test_1/index.html test_2/index.html test_3/index.html`:
#
# index.html
# index 3:45 PM.html
# index 3:45 PM.html (1)
# index 3:45 PM.html (2)


#########################################################
# Lowercase the names of trashed items and trash content
# Used to compare item names and detect duplicates
#########################################################
make_lowercase() {
    echo "$1" | tr "[:upper:]" "[:lower:]"
}


#########################################################
# Check to see if an array contains a value
#########################################################
contains() {
    arr=("$@")
    ((last_idx=${#arr[@]} - 1))
    item=${arr[last_idx]}
    unset arr[last_idx]

    [[ "${arr[@]}" =~ (^| )"$item"($| ) ]] && return 0 || return 1
}


#######################################################################################
# Check to see if the target is a directory or a file with no extension
#######################################################################################
has_no_extension() {
    [[ -d "$1" || "$1" != *"."* ]] && return 0 || return 1   
}


#######################################################################################
# In the event that an item with the same name is already in either the trash
# or the current batch of trashed items, construct its custom-formatted name.
#######################################################################################
handle_name() {
    if has_no_extension "$1";
    then
        # handle_move "$1" "${2} ${time}"
        echo "${2} ${time}"
    else
        name="${2%.*}"
        extension="${2##*.}"
        # handle_move "$1" "${name} ${time}.${extension}"
        echo "${name} ${time}.${extension}"
    fi   
}


#########################################################
# Move the target files/directories into the trash
#########################################################
handle_move() {
    lowercase_name=$( make_lowercase "$2" )
    # Count any duplicates in the batch of items that have been trashed during this operation;
    # for example, $ trash x a/x y/x z/x
    # This number will be appended to the modified file name as a unique identifier.
    dup_count=$( grep -o "$lowercase_name" <<< "${trashed_items[*]}" | wc -l | tr -d " " )

    if [ "$dup_count" -gt 0 ]
    then
        mv -fv "$1" ~/.Trash/"$2 ($dup_count)"
    else
        mv -fv "$1" ~/.Trash/"$2"
    fi

    # Push the lowercased, single-quoted item into the array of trashed_items,
    # used when checking for the existence of an identically-named item.
    lci=$( make_lowercase "$2" )
    trashed_items+=("'$lci'")
}


#########################################################
# Initialization
#########################################################
usage="usage: trash source1 source2 ... sourceN"
time=$(date "+%-I.%M.%S %p") # Format the time like 9.32.16 PM - the "-" trims the leading 0.
trash_content=$( ls ~/.Trash ) # Put the contents of the trash into an array.
trashed_items=() # An empty array to hold items trashed during this execution.
lowercase_trash_content=()

# Loop through the trash, lowercasing every item and wrapping it in single-quotes.
# Single quotes allow for item name comparisons where names may contain spaces.
for item in ~/.Trash/*; do
    name=$( basename "$item" )
    lowercase_name=$( make_lowercase "$name" )
    lowercase_trash_content+=("'$lowercase_name'")
done


#########################################################
# Usage - invoked when no arguments passed
#########################################################
if [ "$#" == "0" ]
then
    echo "$usage"
    exit 1
fi


#########################################################
# Execution
#########################################################
while (( "$#" )); do
    # if the item is a directory and ends with a forward slash, strip the slash so it'll correctly match an existing item in the trash.
    source=$( ( [ -d "$1" ] && [ "${1: -1}" == / ] ) && echo "${1%?}" || echo "${1}" )
    name=$( basename "$source" )
    # for comparing file/dir names, use the lowercased basename.
    lowercase_name=$( make_lowercase "$name" )

    # First, check the array of items that have been successfully trashed in this transaction.
    # If there's a match, no need to check the trash content, as we can infer that there's already an item with that name in there.
    # Note that trasehd_items will be an array of single-quoted strings, so lowercase_name should also be wrapped for comparison.
    if contains "${trashed_items[@]}" "'${lowercase_name}'" || contains "${lowercase_trash_content[@]}" "'${lowercase_name}'"
    then
        custom_name=$( handle_name "$source" "$name" )
        handle_move "$source" "$custom_name"
    else
        handle_move "$source" "$name"
    fi

    shift
done
